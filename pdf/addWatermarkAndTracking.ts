
import { PDFDocument, rgb, StandardFonts, degrees } from 'pdf-lib';
import { v4 as uuidv4 } from 'uuid';
import { ReportData } from './types';
import { supabase } from '@/integrations/supabase/client';

export interface WatermarkConfig {
  text: string;
  enabled: boolean;
  opacity?: number;
}

export interface TrackingConfig {
  userId: string;
  timestamp: number;
  vinHash?: string;
  enabled: boolean;
}

export function generateTrackingId(userId: string, vin?: string): string {
  const timestamp = Date.now();
  const vinPart = vin ? vin.slice(-6) : 'NOVIN';
  const userPart = userId.slice(0, 8);
  const randomPart = uuidv4().slice(0, 8);
  
  return `CD-${userPart}-${vinPart}-${timestamp}-${randomPart}`.toUpperCase();
}

export function createWatermarkConfig(isPremium: boolean = false): WatermarkConfig {
  return {
    text: isPremium 
      ? 'CarPerfector Premium Valuation â€“ For Dealer Use Only'
      : 'CarPerfector Valuation Report',
    enabled: true,
    opacity: 0.1
  };
}

export function createTrackingConfig(userId: string, vin?: string): TrackingConfig {
  return {
    userId,
    timestamp: Date.now(),
    vinHash: vin ? btoa(vin).slice(0, 8) : undefined,
    enabled: true
  };
}

export function formatTrackingInfo(trackingId: string, reportData: ReportData): string {
  return `
Document ID: ${trackingId}
Generated: ${new Date(reportData.generatedAt).toLocaleString()}
Vehicle: ${reportData.year} ${reportData.make} ${reportData.model}
${reportData.vin ? `VIN: ${reportData.vin}` : ''}
CarPerfector.com - Premium Vehicle Valuations
  `.trim();
}

export async function addWatermarkToPdf(
  pdfBytes: Uint8Array,
  trackingId: string,
  watermarkConfig: WatermarkConfig
): Promise<Uint8Array> {
  try {
    const pdfDoc = await PDFDocument.load(pdfBytes);
    const pages = pdfDoc.getPages();
    const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
    
    const watermarkText = `Generated by CarPerfector | Report ID: ${trackingId}`;
    
    for (const page of pages) {
      const { width, height } = page.getSize();
      
      // Add watermark at bottom-right
      page.drawText(watermarkText, {
        x: width - 300,
        y: 20,
        size: 8,
        font,
        color: rgb(0.6, 0.6, 0.6),
      });
      
      // Add subtle background watermark if enabled
      if (watermarkConfig.enabled) {
        page.drawText(watermarkConfig.text, {
          x: width / 2 - 100,
          y: height / 2,
          size: 24,
          font,
          color: rgb(0.9, 0.9, 0.9),
          opacity: watermarkConfig.opacity || 0.1,
          rotate: degrees(45), // Use degrees() helper function
        });
      }
    }
    
    return await pdfDoc.save();
  } catch (error) {
    console.error('Error adding watermark to PDF:', error);
    // Return original PDF if watermarking fails
    return pdfBytes;
  }
}

export async function logPdfGeneration(
  trackingId: string,
  vin: string,
  userId: string
): Promise<void> {
  try {
    const { error } = await supabase
      .from('pdf_audit_logs')
      .insert({
        vin,
        tracking_id: trackingId,
        user_id: userId,
        created_at: new Date().toISOString()
      });
    
    if (error) {
      console.error('Failed to log PDF generation:', error);
    }
  } catch (error) {
    console.error('Error logging PDF generation:', error);
    // Don't throw - logging failure shouldn't break PDF generation
  }
}
